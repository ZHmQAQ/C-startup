史上最简单的递归：main 函数调用自己
```c
int main()
{
    printf("NB\n");
    return main();
	return 0;
}
```
报错：**栈溢出 (stack overflow)**。递归常见错误。

### 练习 1 打印每一位
接收一个整型值（无符号），按照顺序打印每一位，例如，输入 1234，输出 1 2 3 4
```c
//##########打印每一位##########
void num_Print(unsigned int n)
{
	//思路：%10、/10,逆序输出
	if (n >= 10)
		num_Print(n / 10);
	printf("%d ", n%10);
}
```
### 练习 2 求字符串长度
要求不允许创建临时变量，求字符串长度。
```c
//##########字符串长度##########
int get_str_Len(char* ch)
{
	//char* ch表示输入的字符串的指针，从头到尾扫一遍，如果出现\0就终止
	if (*ch == '\0')
		return 0;
	return 1 + get_str_Len(ch+1);//ch+1，即指针往后移动一格
	//对于指针，我还是不甚了解……
	//数组传参，传过去的不是整个数组，而是首元素的地址
}
```

### 练习 3 递归求阶乘
写一个函数求 n 的阶乘（不考虑溢出）。
```c
//##########求n的阶乘##########
int factorial(int n)
{
	if (n == 0)
		return 1;
	return factorial(n - 1) * n;
}

```

### 练习 4 斐波那契数列
写一个函数求斐波那契数列第 n 项（不考虑溢出）。
```c
//##########求斐波那契数列第n项##########
int fibonacci(int n)
{
	//斐波那契数列：1,1,2,3,5,8,13……
	//当n>=3，a(n) = a(n-1)+a(n-2)
	if (n == 1 || n == 2)
		return 1;
	return fibonacci(n - 1) + fibonacci(n - 2);
	//程序时间复杂度O(2^n)，效率非常低下
}
```
在求斐波那契数列的过程中，发生了重复计算的现象，例如
              a50</br>
        a49         a48</br>
     a47  a48     a46   a47</br>
a45 a46 a46 a47 a44 a45 a45 a46</br>
……</br>
在这个角度，递归不如循环，接下来写一个函数，用循环来求斐波那契数列</br>
在求斐波那契数列这个问题上，虽然使用递归代码精简逻辑简单，但是效率过低
```c
int fibonacchi_opt1(int n)
{
	//求斐波那契数优化版
	//opt的意思是optimized，优化版
	//因为递归是逆推，循环是正推，且可以储存数据，尝试使用循环的方法
	long n1 = 1;
	long n2 = 1;
	long n3 = 1;
	for (int i = 2; i < n; i++)
	{
		n3 = n2 + n1;
		n1 = n2;
		n2 = n3;
	}
	return n3;
}
```
递归其他问题：规模太大的时候，会发生栈溢出。

### 练习 5 汉诺塔问题
三根柱子 ABC，A 柱上有 n 个环，上小下大，依次堆叠。游戏目标是，利用 B 柱，将 A 柱上的所有的环到从 A 柱移动到 C 柱，并保持上小下大的模式。一次仅能移动一个环。
![汉诺塔问题](/汉诺塔问题.png "汉诺塔问题")
	
