## 算数操作符
`+`</br>
`-`</br>
`*`</br>
`/`</br>
### 除法运算符 /
```c
	int a = 5 / 2;
	printf("%d\n", a);//输出结果2
	double b = 5/2.0;
	double c = 5/2;
	printf("b = %lf c = %lf\n", b, c);//输出结果b = 2.500000 c = 2.000000
```
整数除法和浮点除法不一样。</br>
**一定要注意，做浮点除法的时候，除式 or 被除式要有一个是浮点**</br>
### 取模运算符 %
```c
	//double a = 5 % 2.0;//不合法
```
不合法，提示取模操作符右边不能是浮点类型。
## 移位操作符
`<<`</br>
`>>`</br>
### 原码、反码、补码
整数有3中储存方式，存储到内存的是补码。</br>
对于正数，源码反码补码都一样。</br>
在计算机中，用 32 个比特位存储 int 类型的数据。其中，第一位数字是 0 还是 1，决定了这个数是正数还是负数。</br>
**反码**：原码符号位不变，其他位按位取反。</br>
**补码**：反码 +1。</br>
以 1 和 -1 分别举例。省略中间24个0。
|十进制|    原码    |    反码    |    补码    |
|------|-----------|-----------|-----------|
|   1  |0000...0001|0111...1110|0111...1111|
|  -1  |1000...0001|1111...1110|1111...1111|

### 左移和右移操作符
`>>` 和 `<<` 是右移操作符和左移操作符，移动的是二进制位。
```c
	int a = 16;
	a >> 1;
	printf("%d\n", a);
```
右移操作符有两种移动方式：算数右移和逻辑右移。</br>
算数右移：右边丢弃，左边补原符号位（符号位：负数是 1，正数是 0）</br>
逻辑右移：右边丢弃，左边补 0.</br>
右移要分为算术移位和逻辑移位。</br>
左移没有逻辑移位和算术移位的差别。</br>

规律：左移：乘二；右移：除以二（扔掉小数）。（-1 和 1 特殊讨论）</br>
**注意事项**：</br>
1、移位的数字只能是正数，例如`int b = a >> -1;`就是未定义的行为。</br>
2、只能作用于整数。
## 位操作符
& </br>
| </br>
^ 
```c
	//###########位操作符##########
	// & 按位与：有 1 则 1，同 1 才 1
	// | 按位或：有 0 则 0，同 0 才 0
	// ^ 按位异或：同则为 ，不同为 1
	int a = 3;//0x24 00000011
	int b = 9;//0x24 00001001
	// 3 & 9 = 0x24 00000001 = 1
	// 3 | 9 = 0x24 00001011 = 11
	// 3 ^ 9 = 0x24 00001010 = 10
	printf("a = 3, b = 9\n\na & b = %d\n\na | b = %d\n\na ^ b = %d\n", a & b, a | b, a ^ b);
```
### 练习 1：int 交换
不创建临时变量，交换两个int类型的变量值
可以想到的一种可行的方法是，`a = a + b; b = a - b; a = a - b;`但是利用位操作符可以实现更加精妙的操作。
```c
	printf("交换前：a = %d  b = %d\n", a, b);
	//int_swap(a, b);//利用位操作符完成两个整型的交换
	a = a ^ b;
	b = a ^ b;
	a = a ^ b;
	printf("交换后：a = %d  b = %d\n", a, b);
```
这个算法太妙了，既不用临时变量，还避免了溢出。

### 练习 2：数二进制 1 的个数
求一个正数存储在内存中的二进制中的 1 的个数。
```c
//##########求 1 个数##########
int count_1(unsigned int x)
{
	//短除法求 1 的个数
	int count = 0;
	while (x)
	{
		if (x % 2 == 1)
			count++;
		x = x / 2;
	}
	return count;
}
```
很遗憾的是，上述函数在计算负数的时候无法正常工作，需要一些更好的处理方法。
我们考虑按位与的操作。把待检测数字与 1 按位与，如果结果是 1，则说明待测数字末位是 1，count ++，否则是 0；然后将
待测数字向右移动一位，继续比较。重复31次；最后，如果被测数字是负数，那么就 count ++（如果是逻辑右移，那就省略负数检测）</br>
**与 1 按位与，然后右移**</br>
```c
int count_1_opt(int x) 
{
	//移位法求 1 的个数
	int count = 0;
	for (int i = 0; i < 32; i++)
	{
		if (1 == ((x >> i) & 1))//这里需要注意括号的使用，来调整运算优先级
			count++;
	}
	return count;
}
```
貌似还有更精妙的方法。只能说，二进制的世界太奇妙了，在后续的考研学习中我肯定会接触到更多这类型的问题，暂时先离开这片神奇空间，进入下一个部分的学习。
## 赋值操作符
`=`</br>
用得很多的功能。注意与`==`区分，特别容易出错。
### 复合赋值操作符
`+=`</br>
`-=`</br>
`*=`</br>
`/=`</br>
`%=`</br>
`>>=`</br>
`<<=`</br>
`&=`</br>
`|=`</br>
`^=`</br>
其实只是一种简洁的写法，没什么神奇的地方。
## 单目操作符
双目操作符：例如 `+  -  *  /  &  >>`，都是需要左右两个操作数
单目操作符：
`!`</br>
`-`</br>
`&`</br>
`*`</br>
`sizeof()`</br>
`~`</br>
`++`</br>
`--`</br>
`(类型)`
```c
	// sizeof
	//tricky example
	short s = 0;
	int a = 10;
	printf("%d\n",sizeof(s = a + 5));
	printf("%d\n", s);
```
输出结果是 2 0</br>
**两个知识点**：
1、在用 int 对 short 赋值的时候，short 存不下，sizeof 还是按照 int 的大小来计算；
2、sizeof()中的运算符是不参与计算的；
```c
	// ~
	//按位取反
	int a = 0;
	printf("%d\n", ~a); // -1
```
```c
	// ++
	// 左 ++，右 ++
	int a = 0;
	printf("%d\n", ++a); //先 ++，再 print 1
	printf("%d\n", a++); //先 print 1，再 ++
	printf("%d\n", a); // 2
```
```c
	// (int) (float) 强制类型转换
	int a = (int) 3.14;
	printf("%d\n", a); // 3
```
## 关系操作符
` ==`</br>`>=`</br>`<=`</br>`>`</br>`<`</br>`!=`</br>
## 逻辑操作符
`&&`</br>`||`</br>``</br>
```c
	printf("%d\n", 3 && 4); // 1
```
### 练习 3：计算下列程序的运行结果





 


