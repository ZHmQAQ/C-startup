> Problem: [1388. 3n 块披萨](https://leetcode.cn/problems/pizza-with-3n-slices/description/)

[TOC]
# 思路
这道题非常困难（对我来说），有以下几个需要深思的点：

---

## 化归：逆向思考
化归是这道题最重要的思路，有了它可以极大程度上简化问题，降低思维难度。

首先先将任务目标简化成数学语言：
* **对于循环数列 A[3n]，要寻找一个满足条件的子序列 B[n]**；

—— 我们将这个子序列称为“取披萨序列”。

接下来我们找一找这个子序列有什么性质。我们可以得到一个感性认知，那就是 B[n] 好像不能取连续的两个元素，进而举例子，可以发现
* **似乎 “取披萨序列” B[n] 与 “A[3n] 的一个不含连续元素的子序列”等价**！

发现这个结论就可以做题了，但下面还是严格证明一下。
```
假设：
命题 P：序列是一个正当的“取披萨序列”；
命题 Q：序列是一个不含相邻元素的子数组；
```
从**逆向角度**思考：如果我们不是要“把一整块披萨分成小块拿走”，而是“把各自的披萨小块还原成一整块”，应该如何处理？

很明显，每当我放回一块披萨，Alice 和 Bob 就会各自在我放回的披萨两侧放上他们的披萨；接下来我如果要再放回披萨，就必须在他们放披萨的左边或是右边：很明显可以得出结论：

我 不可能把两块披萨放在一起，反过来说就是：
**我 不可能取走两块相邻的披萨。**

我们用逆向过程证明了，**一个正当的“取披萨序列”必然是一个不含相邻元素的子数组**。
```
得证：P => Q;
```

那么，一个没有相邻元素的子数组，一定可以获取对应的“取披萨序列”（即 B => A）吗？下面我们用一个具体的例子来尝试证明一下：
```
假设有数组 A3n = {a1, a2, a3, a4, a5, a6, ... , a3n} 
(简记为{1, 2, 3, 4, 5, 6, ... , 3n})
要证 A3n 的任意“不含相邻元素的子数组” Bn[i]，都对应一种满足要求的取法

数学归纳法：
当 n = 1 时，显然成立，因为：
    {1, 2, 3} 中 可以任取一个元素作为子数组；
当 n = k 时，若成立，即：
    A3k = {1, 2, 3, ... ,3k-2, 3k-1, 3k} 的 任意 Bk[i]，都存在满足要求的取法
当 n = k + 1 时，
    A3k+3 = {1, 2, 3, ... , 3k, 3k+1, 3k+2, 3k+3} ，需要在原数组插入一项选择和两项不选，无论增加的一项选择位于原数组的哪里，都可以找到一个位置，使其左右两侧都没有选中，满足题目要求。


```
```
得证：P <=> Q
```

---

因此，我们
* 只需要找一个**不含相邻元素的子数组**就行，**任意**这样的子数组都能对应分披萨的某种情况。

## 状态转移方程
我们先做一道这样的题目：在 n 个元素的数组中，选择 m 个不相邻的元素，找出这个选法的最大值。

先考虑 m = 1 的情况，我们的思路是循环遍历数组用一个记录变量，来记录当前的最大值：
```c
    maxval = 0;
    for(int i = 0; i < n; i++)
        maxval = max(currval[i],maxval);
    return maxval;
```
其实这个过程就是维度降低之后的动态规划过程，我们也可以直接用一个一维数组进行动态规划的写法：

```c
    maxval[n] = {0};
    for(int i = 0; i < n; i++)
        maxval[i] = max(currval[i],maxval[i-1]);
    return maxval[n-1];
```
在这个写法里，我们创建了一个数组来记录“到目前为止的最大值”，状态转移方程为：
$$dp[i] = max(dp[i-1],S[i])$$

如果是 m = 2 的情况，我们的思路是：寻找最大的“两个值”，如果这两个值不是相邻的，则满足要求。然而事实上就会出现一些比较麻烦的情况，例如最大值和次大值恰好是相邻的。这时候可以考虑这样解决：
```c
    maxval1[n] = {0};
    maxval2[n] = {0};
    for(int i = 0; i < n; i++)
        maxval1[i] = max(currval[i],maxval1[i-1]);
    for(int i = 2; i < n; i++)
        maxval2[i] = max(currval[i] + max1val[i-2], maxval[i])
```
可以看到，在 m = 2 的情形下，我们使用了两个记录数组，它们的意义分别是：
- **maxval1[i]** 记录“如果要选出一个值使其最大，那么到 i 为止的最大值”
- **maxval2[i]** 记录“如果要选出两个值使其‘和’最大，那么到 i 为止的最大值”

那么，我们就可以以此类推：
- **maxval[k][i]** 记录“如果要选出 k 个元素的和的最大值，那么到 i 为止的最大值”

那么，在遍历更新完这个二维数组 maxval[m][n]之后，其最右下角的值即为 “n 个元素的数组中选出 m 个不相邻元素的最大和”

这也就是为什么这道题采用二维数组动态规划。

接下来，考虑动态规划的状态转移方程；

$$dp[i][j] = max(dp[i-1][j-2] + S[j], dp[i][j-1])$$

这个状态转移方程其实并不难理解。对于“在前 j 个元素中，选出 i 个不相邻元素使其和最大”这样的要求，我们只需要保证在第 j 次选择的时候，要么选择该元素，要么不选；选择的话，那么此时的最大值就是 $dp[i-1][j-2] + S[j]$；如果不选该元素，那么此时的最大值就是 $dp[i][j-1]$，我们只需要选择两者之中较小值就可以了。

为了进一步帮助理解这个状态转移方程，在这里提及一下和这个问题类似的“打家劫舍”问题。

## “打家劫舍”动态规划
> problem198. [打家劫舍](https://leetcode.cn/problems/house-robber/solutions/2393637/c198-da-jia-jie-she-ying-gai-shi-yi-dao-45waz/)

“打家劫舍”问题是说，从 n 个房屋中选择 m 个不相邻的房屋进行抢劫，每个房屋有不同的价值，返回能抢劫的最大金额。

在这道题中，我们把 抢劫第 i 个房屋能获取的最大金额作为核心进行考虑。在进行第 i 次抢劫的时候，和这道题类似，有两种选择，一种是抢劫当前房屋，那么做这种选择的前提是上一个房屋没有抢，状态转移方程是：$dp[i] = dp[i-2]+S[i]$，一种是不抢劫当前房屋，那么此时的状态转移方程就等于“抢劫上一个房屋”的值：$dp[i]=dp[i-1]$。之后取这两个值的较大值即可。

$$dp[i] = max(dp[i] = dp[i-2]+S[i],dp[i]=dp[i-1])$$

可以看到，这个状态转移方程和这道题有类似之处，但不同点在于“打家劫舍”问题不需要考虑“只取 m 个元素”的问题，而是追求尽可能多地取元素，因此可以避免使用二维动态规划。

## 环形数组问题
> problem213. [打家劫舍II](https://leetcode.cn/problems/house-robber-ii/solutions/2393706/c213-da-jia-jie-she-iihuan-xing-da-jia-j-mtqk/)

这道题还有一个麻烦之处，在于数组是环形的，需要考虑首位处元素的取值问题，多了一层限制条件，也就是说，除了要考虑元素不能相邻，还要考虑首位元素不能同时取得的问题。对于“**环形数组**”，处理这类问题的一般思路是分情况讨论，也就是**写两个动态规划数组**，其中一个在设置初值的时候是取了首元素，另一个不取首元素。

下面，用环形“打家劫舍问题”举例。
```c
// 主要是初始化的时候有轻微区别
int val1[100] = {0}; 
val1[0] = S[0]; val1[1] = S[0];
int val2[100] = {0};
val2[0] = 0; val2[1] = S[1];
for(int i = 2; i < n; i++){
    val1[i] = max(val1[i-1],val1[i-2]+S[i]);
    val2[i] = max(val2[i-1],val2[i-2]+S[i]);
}
// 返回的时候也要使用不同的逻辑，val1 不能取尾元素， val2 可以取
return max(val1[n-2],val2[n-1]);
```
因此对这道题也要如法炮制，对于其初始化和返回值，要分两种情况讨论。

## 滚动数组优化二维数组
大部分情况下，状态转移方程其实只需要用到前面几个数值，这时候我们可以给数组降低维度，一维数组降低为 几个变量，二维数组降低为 几个一维数组。这样的话需要频繁更新数组，因此这样的方法称为“滚动数组”。暂时就先跳过这个优化方法了，不重要。

# 解题方法
## DP 数组初始化
要注意，由于是环形数组问题，需要初始化两下。当然，也可以只初始化一下，但是就要跑两遍数组。
```c
    // 这个初始化是要选择第一项元素的情况
    dp[0][0] = slices[0]; dp[1][0] = slices[0];
    for(int i = 2; i < slicesSize; i++)
        dp[i][0] = max(dp[i-1][0],slices[i]);

    // 不取首元素
    dp[0][0] = 0; dp[1][0] = slices[1];
    for(int i = 2; i < slicesSize; i++){
        dp[i][0] = max(dp[i-1][0],slices[i]);
```
## DP 数组遍历更新
```c
for(int i = 2; i < slicesSize; i++)
        for(int j = 1; j <= slicesSize / 3; j++)
            dp[i][j] = max(dp[i-1][j], dp[i-2][j-1] + slices[i]);
```
这一步反而是最简单的。

## 返回
对于是否取首元素的两种情况，返回其中的较大值
```c
int max1 = dp1[slicesSize-2][slicesSize/3-1];

int max2 = max(dp2[slicesSize-3][slicesSize/3-2] + slices[slicesSize-1], dp[slicesSize-2][slicesSize/3-1]);

return max(max1,max2);
```
这里可以有一个小优化，就是在选取首元素的情况下，max1 可以不用进行一次比较，直接返回 `dp[slicesSize-2][slicesSize/3-1]`，也就是倒数第二个元素的最大值。

# 复杂度
- 时间复杂度: 
$O(n^2)$

- 空间复杂度: 
$O(n^2)$
有优化空间，但是意义不大。

# Code
```C []
#define max(a,b) ((a) > (b) ? (a) : (b))

int maxSizeSlices(int* slices, int slicesSize){
    if(slicesSize == 3)
        return max(max(slices[0],slices[1]),slices[2]);

    // 问题转化：3n 中 选 n 个不相邻元素
    // 这一点我没想到，看了答案，恍然大悟并在此基础上做题。


    int dp[500][167]; 
    memset(dp,0,sizeof(500*167*sizeof(int)));
    // i, j 表示前 i + 1 个元素中，取 j + 1 次的最大情况   
    // 状态转移方程：
    // dp[i][j] = max{dp[i-1][j], dp[i-2][j-1] + S[i][j]} 
    // 取值范围：0 <= i <= n;

    // 初始状态：
    // 取一个：dp[i][0] = max(dp[i-1][0],S[i])

    // 取首元素：dp[0][0] = S[0], dp[1][0] = S[0], dp[2][0] = S[0];
    // dp[n-1][n/3-1] = dp[n-2][n/3-1];
    // 不取首元素：dp[0][0] = 0, dp[1][0] = S[1], dp[2][0] = S[1]
    // dp[n-1][n/3-1] =  max(dp[n-3][n/3-2] + S[n-1], dp[n-2][n/3-1])

    // initialize dp[][]
    // 取首元素
    dp[0][0] = slices[0]; dp[1][0] = slices[0];
    for(int i = 2; i < slicesSize; i++){
        dp[i][0] = max(dp[i-1][0],slices[i]);
    }
    for(int i = 2; i < slicesSize; i++){
        for(int j = 1; j <= slicesSize / 3; j++){
            dp[i][j] = max(dp[i-1][j], dp[i-2][j-1] + slices[i]);
        }
    }
    int max1 = dp[slicesSize-2][slicesSize/3-1];
    
    // for(int i = 0; i < slicesSize; i++){
    //     printf("\n");
    //     for(int j = 0; j < slicesSize/3; j++)
    //     printf("%d ", dp[i][j]);
    // }
    // 不取首元素
    dp[0][0] = 0; dp[1][0] = slices[1];
    for(int i = 2; i < slicesSize; i++){
        dp[i][0] = max(dp[i-1][0],slices[i]);
    }
    for(int i = 2; i < slicesSize; i++){
        for(int j = 1; j <= slicesSize / 3; j++){
            dp[i][j] = max(dp[i-1][j], dp[i-2][j-1] + slices[i]);
        }
    }
    int max2 = max(dp[slicesSize-3][slicesSize/3-2] + slices[slicesSize-1], dp[slicesSize-2][slicesSize/3-1]);

    // printf("%d %d", max1, max2);
    // for(int i = 0; i < slicesSize; i++){
    //     printf("\n");
    //     for(int j = 0; j < slicesSize/3; j++)
    //     printf("%d ", dp[i][j]);
    // }

    return max(max1,max2);

}
```
