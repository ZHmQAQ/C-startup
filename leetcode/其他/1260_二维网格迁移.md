
> Problem: [1260. 二维网格迁移](https://leetcode.cn/problems/shift-2d-grid/description/)

[TOC]

# 思路

第一反应模拟，仔细看题之后发现可以直接计算 k 次迁移之后的位置。

# 解题方法

创建了很多变量，实际上都可以简化，只是为了理清思路所以这样一步一步写。

# 复杂度

时间复杂度:
$O(n * m)$
需要遍历数组

空间复杂度:
$O(n * m)$
需要复制数组



# Code
```C++ []
class Solution {
public:
    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {
        // 不会真的有人模拟吧
        // m * n 次一循环
        int m = grid.size(); // 行数
        int n = grid[0].size(); // 列数
        k = k % (m * n);
        int a = k % n; // 列偏移量
        int b = k / n; // 行偏移量
        cout << k << " " << a << " " << b;
        // 接下来遍历数组，根据偏移量赋值就可以
        vector<vector<int>> newgrid(grid);
        for(int i = 0; i < m; i++)
            for(int j = 0; j < n; j++){
                // newc = (oldc + a) % n
                // newr = (oldr + b + (oldc+ a) / n) % m
                int oldc = j;
                int oldr = i;
                int newc = (oldc + a) % n;
                int newr = (oldr + b + (oldc + a) / n) % m;
                newgrid[newr][newc] = grid[i][j];
            }
        return newgrid;
    }
};
```
  
