> Problem: [1921. 消灭怪物的最大数量](https://leetcode.cn/problems/eliminate-maximum-number-of-monsters/description/)

[TOC]

# 思路
把怪物抵达时间从小到大排序，再将时间与它们的下标进行比较，如果时间比下标更小，说明在时间到了的情况下也打不完。

# 解题方法
我使用了浮点数数组记录 time ，这个实在是有点蠢，但是胜在方便。


# 复杂度
- 时间复杂度: 
$O(nlogn)$
快排时间消耗

- 空间复杂度: 
$O(n)$
浮点数组创建

# Code
```C []

int cmp(const void* _a, const void* _b) {
    const float* a = (const float*)_a;
    const float* b = (const float*)_b;

    if (*a < *b) return -1;
    if (*a > *b) return 1;
    return 0;
}

int eliminateMaximum(int* dist, int distSize, int* speed, int speedSize){
    float* time = malloc(sizeof(float)*distSize);
    for(int i = 0; i < distSize; i++)
        time[i] = (float)dist[i] / (float)speed[i];
    qsort(time,distSize,sizeof(float),cmp);
    // 排序完从第二个怪开始打就行，第一个怪反正是必死的

    int count = 1;
    for(int i = 1 ; i < distSize; i++){
        if (time[i] / i <= 1)
            break;
        count++;
    }
    return count;
}
```
