> Problem: [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/description/)

[TOC]

# 思路
动态规划肯定没跑。相较于直线“打家劫舍”问题，环形情形下需要额外考虑末尾元素：如果取了末尾元素，就不能取 0 号元素，因此它的表达式由
$$dp[n-1] = max(dp[n-2], dp[n-3] + S[n-1])$$
变为
$$dp[n-1] = max(dp1[n-2], dp2[n-3] + S[n-1])$$：
其中 `dp1` 和 `dp2` 分别是 取 0 和 不取 0 的情况。因此，需要创建两个 `dp` 数组。

# 解题方法
创建两个 `dp` 数组 `dp1` `dp2`，状态转移方程如下：
$$dp1[i] = max(dp1[i-1], dp1[i-2] + 1) (1 <= i <= n-2)$$
$$dp2[i] = max(dp2[i-1], dp2[i-2] + 1) (3 <= i <= n-2)$$

$$dp[n-1] = max(dp1[n-2], dp2[n-3] + S[n-1])$$

简便地实现对 dp1 和 dp2 的区分，其实只需要在初始化前两个元素的时候分别处理即可：
```c
    dp1[0] = nums[0]; dp1[1] = nums[0];
    dp2[0] = 0; dp2[1] = nums[1];
```
然后就可以一视同仁地扔进循环了：
```c
    for(int i = 2; i < numsSize; i++){
        dp1[i] = max(dp1[i-1], nums[i] + dp1[i-2]);
        dp2[i] = max(dp2[i-1], nums[i] + dp2[i-2]);
    }
```
返回值也要小小修饰一下：
```c
    return max(dp2[numsSize-1],dp1[numsSize-2]);
```

# 复杂度
- 时间复杂度: 
$O(n)$

- 空间复杂度: 
$O(n)$
其实可以 O(1) 的，就是不创建辅助数组，而是用 4 个变量记录 `dp1[i-1]`, `dp2[i-1]`, `dp1[i-2]`, `dp2[i-2]` 即可..

# Code
```C []

#define max(a,b) ((a) > (b) ? (a) : (b))
int rob(int* nums, int numsSize){
    //状态转移方程
    //dp1[i] = max(dp1[i-1], dp1[i-2] + 1) (1 <= i <= n-2)
    //dp1 是 取 0 号元素 的情况
    //dp2[i] = max(dp2[i-1], dp2[i-2] + 1) (3 <= i <= n-2)
    //dp2 是 不取 0 号元素 的情况
    //dp[n-1] = max(dp1[n-2], dp2[n-3] + S[n-1])
    if(numsSize == 1)
        return nums[0];
    if(numsSize == 2)
        return max(nums[0], nums[1]);
    int dp1[100];
    int dp2[100];
    dp1[0] = nums[0]; dp1[1] = nums[0];
    dp2[0] = 0; dp2[1] = nums[1];

    for(int i = 2; i < numsSize; i++){
        dp1[i] = max(dp1[i-1], nums[i] + dp1[i-2]);
        dp2[i] = max(dp2[i-1], nums[i] + dp2[i-2]);
    }

    return max(dp2[numsSize-1],dp1[numsSize-2]);

}
```
