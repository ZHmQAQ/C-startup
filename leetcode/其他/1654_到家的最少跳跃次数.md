> Problem: [1654. 到家的最少跳跃次数](https://leetcode.cn/problems/minimum-jumps-to-reach-home/description/)

[TOC]

# 思路
其实就是模拟的方法，但是可以用图的思想做，模拟这个过程，实际上就是对图的广度优先遍历。

# 解题方法
先将 `forbidden` 数组放入哈希表，便于后续查表。

出队一个结点，然后入队这个结点的前驱节点和后继节点。如果前驱或者后继在 `forbidden` 表中，跳过这个元素。如果出队操作是 “后跳”，本次入队跳过“后跳”操作的元素。

出队的时候也将结点放入 `forbidden` 哈希表。

注意到这题规模不大，所以实际操作的时候可以用 visited 数组（下标数组）来代替哈希。
# 复杂度
- 时间复杂度: 
$O(n)$
这个好复杂，算不太来。

- 空间复杂度: 
$O(n)$

# Code
```C []

#define TABLE_SIZE 5009
#define MAX_POS 6000
#define min(a,b) ((a) < (b) ? (a) : (b))

typedef struct Binode{
    int pos;
    int count;
    bool last_jump_back;  // 标志上一步是否是向后跳
}Binode;

typedef struct queue{
    Binode table[TABLE_SIZE];
    int rear;
    int front;
}Queue;

void enqueue(Queue* queue, Binode ele){
    queue->rear = (1 + queue->rear) % TABLE_SIZE;
    queue->table[queue->rear] = ele;
}

Binode dequeue(Queue* queue){
    queue->front = (queue->front + 1) % TABLE_SIZE;
    return queue->table[queue->front]; 
}

bool not_empty_queue(Queue* queue){
    return queue->rear != queue->front;
}

int minimumJumps(int* forbidden, int forbiddenSize, int a, int b, int x){
    bool visited[MAX_POS][2];
    memset(visited, 0, sizeof(visited));
    
    for(int i = 0; i < forbiddenSize; i++){
        visited[forbidden[i]][0] = true;
        visited[forbidden[i]][1] = true;
    }

    Queue queue;
    memset(&queue, 0, sizeof(queue));
    
    Binode ele0;
    ele0.pos = 0; ele0.count = 0; ele0.last_jump_back = false;
    enqueue(&queue, ele0);
    
    while(not_empty_queue(&queue)){
        Binode ele = dequeue(&queue);
        if(ele.pos == x)
            return ele.count;

        // 向前跳
        if(ele.pos + a < MAX_POS && !visited[ele.pos + a][0]){
            Binode temp;
            temp.pos = ele.pos + a;
            temp.count = ele.count + 1;
            temp.last_jump_back = false;
            visited[temp.pos][0] = true;
            enqueue(&queue, temp);
        }
        
        // 向后跳
        if(!ele.last_jump_back && ele.pos - b > 0 && !visited[ele.pos - b][1]){
            Binode temp;
            temp.pos = ele.pos - b;
            temp.count = ele.count + 1;
            temp.last_jump_back = true;
            visited[temp.pos][1] = true;
            enqueue(&queue, temp);
        }
    }

    return -1;
}

```
