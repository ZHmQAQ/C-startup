
> Problem: [2684. 矩阵中移动的最大次数](https://leetcode.cn/problems/maximum-number-of-moves-in-a-grid/description/)

[TOC]

# 思路

广度优先搜索，将第一列元素入队，出队时将符合条件的元素入队。
队列为空时，最后一个出队元素的列标，即为走过的步数。

# 解题方法

创建一个三元组存储一个元素的 列号，行号，值（make_tuple）。
在将一个元素入队之后，在 grid 中将其赋值为 0，这样其他元素遍历到的时候就不会将其入队了，避免了 visited 数组的使用，正因如此，需要使用 三元组来存储原本的数值信息。


# 复杂度

时间复杂度:
$O(cols * rows)$
最坏情况需要遍历整个矩阵

空间复杂度:
$O(rows)$
额外空间来自队列，队列中元素个数只与列数有关



# Code
```C++ []
class Solution {
public:
    typedef tuple<int, int, int> ele;
    int maxMoves(vector<vector<int>>& grid) {
        // 移动最大次数其实就是最大可达列号
        // 广度优先搜索，将第一列元素入队，出队时将“下一步”位置入队
        // 维护一个 visited 数组，避免重复入队
        // 优化 visited 数组，每次入队之后将元素赋值为 0 也可以避免重复入队
        queue<ele> q;
        size_t cols = grid[0].size();
        size_t rows = grid.size();
        for(int i = 0; i < rows; i++){
            q.push(make_tuple(i,(int)0,grid[i][0]));
        }

        int ret;
        while(!q.empty()){
            ele element = q.front();
            int y = get<0>(element);
            int x = get<1>(element);
            int val = get<2>(element);
            ret = x;
            q.pop();
            if(x == cols - 1)
                return cols - 1;
            if(y != 0 && grid[y-1][x+1] > val){
                q.push(make_tuple(y-1,x+1,grid[y-1][x+1]));
                grid[y-1][x+1] = 0;
            }
            if(y != rows - 1 && grid[y+1][x+1] > val){
                q.push(make_tuple(y+1,x+1,grid[y+1][x+1]));
                grid[y+1][x+1] = 0;
            }
            if(grid[y][x+1] > val){
                q.push(make_tuple(y,x+1,grid[y][x+1]));
                grid[y][x+1] = 0;
            }    
        }
        return ret;
    }
};
```
  
