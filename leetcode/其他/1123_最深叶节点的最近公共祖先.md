> Problem: [1123. 最深叶节点的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/description/)

[TOC]

# 思路
有一个思路是找到最深层的所有结点，然后往上遍历直到找到公共结点，需要用到 BFS 而且一听就非常复杂。

这道题其实可以用递归的方法。一个结点如果它的左右深度相等，那它一定就是一个“公共祖先”，然而有一些小问题：第一，无法确定他所在这条分支的叶节点是的深度是全局最深的叶节点；第二，无法确定所有最深叶节点都在这条分支上。

换个角度考虑：我们只看根节点，如果我们能知道根节点左右两个孩子结点的“高度”，（这里“高度”定义是与最深叶子节点的距离）那么这时候有三种情况：

- 左 < 右
- 左 > 右
- 左 == 右

在前两种情况中，我们想要求的那种结点（lca 结点）一定是在较高的那棵子树上的，因为这样叶节点才会更深；

左 == 右 的 情况下，**我们需要发现一个非常重要的事实：根节点就一定是 lca 结点！！！**

因此，只需要在两棵子树高度不相等的时候递归向更高的那个子结点就行了！直到某个结点左右高度相等，他就是我们的 lca 结点！！！

# 解题方法
其实就是递归，利用到 DFS 或者说 左右根遍历 但有没有突然感觉要是结点中能记录当前节点的高度就好了！这时候可以再定义一个新的结点数据结构包含它的高度！！

C++ 更简单了，可以用 `pair` 啥的。

# 复杂度
- 时间复杂度: 
$O(h)$
h 是树高

- 空间复杂度: 
$O(h)$
递归调用栈深度

# Code
```C []

typedef struct TreeNode Node;
typedef struct{
    Node* node;
    int depth;
}d_Node; // 创建一个新的数据结构，结点包含了它的深度

d_Node lca(Node* node){
    if(node == NULL)           return (d_Node){NULL,0};
    d_Node _l = lca(node->left);
    d_Node _r = lca(node->right);
    if(_l.depth < _r.depth)    return (d_Node){_r.node,_r.depth+1};
    if(_l.depth > _r.depth)    return (d_Node){_l.node,_l.depth+1};
    return (d_Node){node, _l.depth + 1};
}


struct TreeNode* lcaDeepestLeaves(struct TreeNode* root){
    // 一个结点的高度等于左右子树最大高度 + 1
    // DFS 同时记录结点高度
    // 递归成左右子树上的子问题

    return lca(root).node;
}
```
