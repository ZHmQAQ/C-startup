> Problem: [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/description/)

[TOC]

# 思路
## 方法一 化归为合并 2 个升序链表

## 方法二 对比所有的头元素选出最小的

# 解题方法
都不是最好的方法。。。

# 复杂度
- 方法一时间复杂度: 
$O(m * k^2)$
n 是平均链表长度，k 是链表数量。

- 方法二时间复杂度: 
$O(m * k)$
m 是最长的那根链表长度，k 是链表数量。

- 方法一空间复杂度: 
$O(1)$
- 方法二空间复杂度: 
$O(1)$

# Code
## 方法一 化归
```C []
typedef struct ListNode Node;
Node* mergeTwoLists(Node* list1, Node* list2){
    Node dummy;
    Node* end = &dummy;
    while(list1 && list2)
    {
        if(list1->val <= list2->val){
            end->next = list1;
            list1 = list1->next;
        }
        else{
            end->next = list2;
            list2 = list2->next;
        }
        end = end->next;
    }
    if(list1)
        end->next = list1;
    else    
        end->next = list2;
    return dummy.next;
}

Node* mergeKLists(Node** lists, int listsSize){
    if(lists == NULL)
        return NULL;
    Node* ret = NULL;
    for(int i = 0; i < listsSize; i++)
    {
        ret = mergeTwoLists(ret,lists[i]);
    }
    return ret;
}
```
## 方法二 
```c
typedef struct ListNode Node;
void endInsert(Node** end, Node** node, int* notEmptyLists){
    if(*node == NULL)
        return;
    (*end)->next = *node;
    *end = *node;
    (*node) = (*node)->next;
    (*end)->next = NULL;
    if(*node == NULL) // 如果我们从链表中移除了一个节点，就将非空链表的数量减1
        (*notEmptyLists)--;
}
struct ListNode* mergeKLists(struct ListNode** lists, int listsSize){
    if(lists == NULL)
        return NULL;
    Node* ret = malloc(sizeof(Node));
    ret->next = NULL;
    Node* end = ret;
    int notEmptyLists = listsSize;
    for(int i = 0; i < listsSize; i++)
        if(lists[i] == NULL)
            notEmptyLists--;
    while(notEmptyLists>0)
    {
        int i;
        int minval = 10001;
        Node** node = NULL;
        for(i = 0; i < listsSize; i++)
            if(lists[i]!=NULL)
                if(lists[i]->val <= minval){
                    minval = lists[i]->val;
                    node = &(lists[i]);
                }
        endInsert(&end,node,&notEmptyLists);
    }
    return ret->next;
}
```


