> Problem: [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/description/)

[TOC]

# 思路
最开始的思路是创建一个数组，记录从每个元素开始向后累加的最大值，时间复杂度为$O(n^2)$，非常不好。
仔细想一下，发现，如果一个子串要是最大子串，它必然是以一个正数开头的，并且这个正数是在一个正数子串的首项。那么，如果我们从头开始遍历，只需要记录几个“正数子串”的首元素位置，再从这些正数子串出发遍历累加，就可以一定程度优化最开始的思路。
再仔细想一下，既然提出了“正数子串”“负数子串”的概念，那么初始数组可以进行化简：
例如：
`[1,4,-3,-1,-5,6,4,-2]`就可以被简化为`[5,-8,10,-2]`这种正数负数子串相间分布的形式。接下来，我们以一个正数子串+一个负数子串为一组来看，例如第一组`5,-8`和为`-3`，该串被化简为`[-3,10,-2]`，这时候答案已经呼之欲出了。

因此，我们应该完成什么样的操作呢？

——在每次读取元素的时候，判断是正数还是负数。如果是正数，说明此时是在一个正数子串中，每次用`last`记录子串和，并与已经储存的最大值`maxval`相比较；如果遇到负数，依然累加到`last`中，直到`last`小于 0，在此之后如果依然是负数，不计入`last`中，直到等到下一个正数子串，初始化`last`为 0；如果`last`还没减到 0 正数子串就到了，就继续累加。
# 解题方法
- 首先，初始化一个变量 `maxval` 为给定数组 `nums` 的第一个元素。
- 然后，使用变量 `last` 记录当前连续子序列的和，初始化为 0。
- 接下来，遍历数组 `nums` 中的每一个元素，分情况讨论：
- 如果 `maxval` 小于 0，说明当前最大子序和为负数，需要重新开始寻找最大子序和。将当前元素 `nums[i]` 赋值给 `maxval`。
- 如果 `maxval` 大于等于 0，说明当前最大子序和为正数，可以继续扩展子序列。判断当前元素 `nums[i]` 的正负性，分以下两种情况：
    - 如果当前元素为正数，说明可以将其加入到当前连续子序列中，将 `last` 加上 `nums[i]`，并更新 `maxval`。
    - 如果当前元素为负数，说明当前连续子序列已经到达了最大值，无法再扩展。只需将 `last` 加上 `nums[i]`，以便后续可能出现的正数元素。
- 在每一轮遍历结束后，判断 `last` 的值是否小于 0，如果是，则将其重置为 0。
- 最终，返回变量 `maxval`，即为最大子序和。

# 复杂度
- 时间复杂度: 
$O(n)$
只需要遍历一次。

- 空间复杂度: 
 $O(1)$
没有创建额外的数组。
# Code
```C []

int maxSubArray(int* nums, int numsSize){
    int maxval = nums[0];
    int last = 0;
    for(int i = 0; i < numsSize; i++)
    {
        if(maxval < 0)
        {
            maxval = maxval < nums[i] ? nums[i] : maxval;
        }
        if(maxval >= 0)
        {
            if(last >= 0 && nums[i] > 0)
            {
                last += nums[i];
                maxval = maxval < last ? last : maxval;
            }
            if(last >= 0 && nums[i] <= 0)
                last += nums[i];
        }
        if(last < 0)
            last = 0;
    }
    return maxval;
}
```
