## c内置的数据结构类型
### 内置类型
`char`
`short`
`int`
`long`
`double`
### 自定义类型——构造类型
数组类型`int a[5]``char b[20]`
结构体类型`struct name {};`
枚举类型`enum`
联合类型`union`
### 类型的意义
决定开辟空间的大小
如何看待内存空间
### 整型类型 
```c
char //占用一个字节
    unsigned char    //0-255
    signed char      //-128-127
short
    unsigned short
    signed short
int
    unsigned int
    signed int
long
    unsigned long
    signed long
```
### 浮点类型
```c
float
double
```
### 指针类型
大小：4 个字节（32位）/8 个字节（64位）
```c
int* p;
char* pch;
void* pv;
```
### 空类型
`void`

## 重点：整型在内存中的存储：原码、反码、补码
正数有三种表示方式：**原码反码补码**
无符号数：
原码反码补码相同(因为没有符号位)
有符号数：
正数，原码反码补码相同,负数不相同！
### 原码反码补码的转换
原码：直接把十进制翻译成二进制即可
反码：正数不变，负数**符号位不变，其他位按位取反**
补码：正数不变，负数**反码 +1**
```c
    int a = 20;
    //原码 00000000 00000000 00000000 00010100
    //反码 00000000 00000000 00000000 00010100
    //补码 00000000 00000000 00000000 00010100
    //0x00000014
    int b = -10;
    //原码 10000000 00000000 00000000 00001010
    //反码 11111111 11111111 11111111 11110101 符号位不变，其他位取反
    //补码 11111111 11111111 11111111 11110110 反码 + 1
    //0xFFFFFFF6
```
### 补码：整型在内存中的真正存放形式
此处涉及到 cpu 最底层的计算方式
```c
    1 + (-1)
    // 1: 00000000 00000000 00000000 00000001
    //-1: 11111111 11111111 11111111 11111111
    //相加之后，发生溢出，去掉最高位，剩下的：
    // 0：00000000 00000000 00000000 00000000
```
|       | 正数          | 负数           |
|-------|---------------|---------------|
|有符号数|原码反码补码相同|**原码反码补码不同**|
|无符号数|原码反码补码相同|原码反码补码相同|
### 奇怪的 char
`char`在内存中的存储空间只有一个字节，因此要注意各种类型转换时候的“整型提升”和“截断”问题
### 练习 1：判断输出
```c
int main()
{
	char a = -1;
	signed char b = -1;
	unsigned char c = -1;
	printf("%d\n%d\n%d\n", a,b,c);
}
```
**过程和思路：**
注意截断和整型提升。
```c
int main()
{
	char a = -1;
    //原码 10000000 00000000 00000000 00000001
    //反码 11111111 11111111 11111111 11111110
    //补码 11111111 11111111 11111111 11111111
    //11111111
	signed char b = -1;
    //11111111
	unsigned char c = -1;
    //11111111
	printf("%d\n%d\n%d\n", a,b,c);
    //从 char 打印整型的时候，要发生整型提升：整型提升：正数补0，负数补1
    //a：11111111 11111111 11111111 11111111 -> -1
    //b：11111111 11111111 11111111 11111111 -> -1
    //c：00000000 00000000 00000000 11111111 -> 255
}
```
### 练习 2：判断输出
```c
    char a = -128;
    printf("%u\n",a);
```
**过程和思路：**
%u 占位符表示输出无符号整数。
```c
    char a = -128;
    //10000000 00000000 00000000 10000000
    //先变补码，再截断
    //11111111 11111111 11111111 01111111
    //11111111 11111111 11111111 10000000
    //10000000
    printf("%u\n",a);
    //打印十进制的无符号数字
    //整型提升，补 1
    //11111111 11111111 11111111 10000000
    //由于打印 %u，因此不用再把补码变原码了（无符号补码=原码）换算成十进制后直接打印
    //4294967168
```
### 练习 3：判断输出
```c
    char a = 128;
    printf("%u\n",a);
```
**注意事项**：和上题类似。
```c
    char a = 128;
    //溢出了，它就等于 -127
    //10000000 00000000 00000000 10000000
    //先变补码，再截断
    //11111111 11111111 11111111 01111111
    //11111111 11111111 11111111 10000000
    //10000000
    printf("%u\n",a);
    //打印十进制的无符号数字
    //整型提升，补 1
    //11111111 11111111 11111111 10000000
    //由于打印 %u，因此不用再把补码变原码了（无符号补码=原码）换算成十进制后直接打印
    //4294967168
```
### 练习 4：
```c
    int i = -20;
    unsigned int j = 10;
    printf("%d\n", i + j);
```
**注意事项**：加法都是以补码形式运算
```c
    int i = -20;
    //10000000 00000000 00000000 00001100 原码
    //11111111 11111111 11111111 11110011 反码
    //11111111 11111111 11111111 11110100 补码
    unsigned int j = 10;
    //00000000 00000000 00000000 00000110 原码 = 反码 = 补码
    printf("%d\n", i + j);
    //11111111 11111111 11111111 11111010 补码
    //11111111 11111111 11111111 11111001 反码
    //10000000 00000000 00000000 00000110 原码 = -10

```
### 练习 5
```c
    unsigned int i;
    for(i = 9;i>=0;i--)
    {
        printf("%u\n",i);
    }
```
**注意事项**：i 是无符号数字，所以会无限循环。
### 练习 6
```c
    char a[1000];
    int i;
    for(i = 0; i < 1000; i++)
        a[i] = -1 - i;
    printf("%d",strlen(a));//255
```
**注意事项**：当 i 走到 -128 之后，会回到 127 继续减，直到减到 0
0 在 ASCII 码中表示 `\0`，即字符串终止符号，这时候，会终止函数`strlen()`的读取，因此结果是 255
### 练习 7
```c
    unsigned char i = 0;
    for (i = 0; i <= 255; i++)
        printf("helloworld\n");
    return 0;
```
**注意事项**：这道题和练习 5 有异曲同工之妙，由于`char`的取值范围问题，所以造成了死循环
## 大小端、字节数
大端存储模式：数据的高位保存在内存的高地址中，数据的高位保存在内存的低地址中
小端存储模式：vice versa
大多数都是小端存储。小的数字放在左边，看起来就像是放反了一样。
### 练习 1：写一个程序判断内存“字节序”
存储模式是大端存储还是小端存储
思路：查看一个特定数字 的首位，例如，对于数字 1
如果是大端存储，那就是 00 00 00 01
如果是小端存储，那就是 01 00 00 00
用`char`类型的指针把第一位拿出来。
```c
int check_sys()
{
    //如果当前内存存储模式是小端，返回 1；否则返回 0
    int a = 1;
    char* p = (char*)&a;
    return *p;
}
//更精简的写法
int check_sys1()
{
    int a = 1;
    return *(char*)&a;
}
```
## 重点：浮点在内存中的存储
`float`
`double`
`long double`
1E10 浮点数，E 代表科学计数法
### 引入
```c
    int n = 9;
    float *pFloat = (float *)&n;//这里最好用强制类型转换
    printf("      n的值：%d\n", n);
    printf("*pFloat的值：%f\n", *pFloat);
    *pFloat = 9.0;
    printf("      n的值：%d\n", n);
    printf("*pFloat的值：%f\n", *pFloat);
```
```
      n的值：9
*pFloat的值：0.000000
      n的值：1091567616
*pFloat的值：9.000000
```
显然，整型的存储方式和浮点的存储方式是不一样的
### 二进制浮点数的表示：S、E、M
根据 IEEE 754 标准规定，任何一个二进制浮点数 V 可以表示成下面的形式：

* **(-1)^S * M * 2^E**
* (-1)^S 表示符号位，当 S=0，V 为正数，当 S=1，V为负数
* M 表示有效数字，M>=1，M<2
* 2^E 表示指数位

**举例**
```
5.0 
= 101.0 = (-1)^0 * 1.01 * 2^2 
-> S=0，M=1.01，E=2

-5.0
= -101.0 = (-1)^1 * 1.01 * 2^2 
-> S=1，M=1.01，E=2
```
#### S、E、M 的具体存储方式
对于 32 位浮点数，最高 1 位是符号位 S，之后 8 位为指数 E，剩下 23 位为有效数字 M
对于 64 位浮点数，最高 1 位是符号位 S，之后 11 位为指数 E，剩下 52 位为有效数字 M
#### S 的存储
S 代表浮点数的符号，存在首位，0 是正数，1 是负数
#### E 的存储
E 代表浮点数的指数，8 或 11 位
指数也可正可负，但 E 是无符号数，因此存储的时候，先加 127 之后，再转化为二进制。
有点怪，为什么不用有符号的数，然后用第一位代表符号？
其实差不多，只是第一位是 1 的时候代表正数，0 代表负数，和有符号数的存放相反
**举例**
```
0.5
=0.1 = (-1)^0 * 1.0 * 2^(-1)
-> S=0，M=1.0，E=-1
E + 127 = 126
-> (32位)E = 0b01111110
```
**特殊情况**
**E 为全 0**：太小了！E 比 -127 还小，即使加了 127 还是不够 0；这种情况下，我们的处理方式是让 E = -127，有效数字 M 不再加上第一位的 1，而是还原为 0.xxx 的小数。
**E 为全 1**：太大了！E 比 128 还大；如果 M 全为 0，表示一个正/负无穷大的数字。
#### M 的存储
**十进制小数转化为二进制小数**
将十进制的小数转化为二进制的小数，可以采用以下步骤：

1. **将小数部分乘以2，得到整数部分和小数部分**。例如，对于0.625这个小数，将其乘以2，得到1.25，整数部分为1，小数部分为0.25。
2. 将上一步得到的**整数部分记录下来，然后将小数部分继续乘以2**，得到新的整数部分和小数部分。例如，对于0.25这个小数，将其乘以2，得到0.5，整数部分为0，小数部分为0.5。
3. 重复上述步骤，直到**小数部分为0或者达到了所需的精度**。例如，对于0.625这个小数，不断进行上述步骤，得到二进制小数为0.101。
   
需要注意的是，如果小数部分不是无限循环小数，那么上述步骤最终会得到一个有限位数的二进制小数。如果小数部分是无限循环小数，那么上述步骤会一直重复下去，直到达到所需的精度为止。

**举例**
```
5.5 在内存中的存储形式
5.5
= 101.1 = (-1)^0 * 1.011 * 2^2
-> S=0，M=1.011，E=2
-> 0 10000001 01100000000000000000000
```
回到“引入”中的例子：
```c
    int n = 9;
    float *pFloat = (float *)&n;
    printf("      n的值：%d\n", n);//9
    printf("*pFloat的值：%f\n", *pFloat);//0.000000 (%f 只打印到小数点后 6 位)
    //(int)9 = 00000000 00000000 00000000 00001001
    //用浮点的方式解码上述二进制序列：
    //0 00000000 00000000000000000001001
    //E 全 0，代表是一个极小的数字，用特殊情况的计算方法
    //= (-1)^0 * 2^(-127) * 0.00000000000000000001001
    //= 2^(-147) * 1.125
    *pFloat = 9.0;
    printf("      n的值：%d\n", n);//1091567616
    printf("*pFloat的值：%f\n", *pFloat);//9.000000
    //(float)9.0 = 1001.0 = (-1)^0 * 1.001 * 2^3
    //-> S=0，M=1.001，E=3
    //-> 0 10000010 00100000000000000000000
    //用整型的理解方式解码上述二进制序列：
    //-> 01000001 00010000 00000000 00000000 = 2^31 + 2^25 + 2^21 = 1091567616
```

