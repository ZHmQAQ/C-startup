## c内置的数据结构类型
### 内置类型
`char`
`short`
`int`
`long`
`double`
### 自定义类型——构造类型
数组类型`int a[5]``char b[20]`
结构体类型`struct name {};`
枚举类型`enum`
联合类型`union`
### 类型的意义
决定开辟空间的大小
如何看待内存空间
### 整型类型 
```c
char //占用一个字节
    unsigned char    //0-255
    signed char      //-128-127
short
    unsigned short
    signed short
int
    unsigned int
    signed int
long
    unsigned long
    signed long
```
### 浮点类型
```c
float
double
```
### 指针类型
大小：4 个字节（32位）/8 个字节（64位）
```c
int* p;
char* pch;
void* pv;
```
### 空类型
`void`

## 重点：整型在内存中的存储：原码、反码、补码
正数有三种表示方式：**原码反码补码**
无符号数：
原码反码补码相同(因为没有符号位)
有符号数：
正数，原码反码补码相同,负数不相同！
### 原码反码补码的转换
原码：直接把十进制翻译成二进制即可
反码：正数不变，负数**符号位不变，其他位按位取反**
补码：正数不变，负数**反码 +1**
```c
    int a = 20;
    //原码 00000000 00000000 00000000 00010100
    //反码 00000000 00000000 00000000 00010100
    //补码 00000000 00000000 00000000 00010100
    //0x00000014
    int b = -10;
    //原码 10000000 00000000 00000000 00001010
    //反码 11111111 11111111 11111111 11110101 符号位不变，其他位取反
    //补码 11111111 11111111 11111111 11110110 反码 + 1
    //0xFFFFFFF6
```
### 补码：整型在内存中的真正存放形式
此处涉及到 cpu 最底层的计算方式
```c
    1 + (-1)
    // 1: 00000000 00000000 00000000 00000001
    //-1: 11111111 11111111 11111111 11111111
    //相加之后，发生溢出，去掉最高位，剩下的：
    // 0：00000000 00000000 00000000 00000000
```
|       | 正数          | 负数           |
|-------|---------------|---------------|
|有符号数|原码反码补码相同|**原码反码补码不同**|
|无符号数|原码反码补码相同|原码反码补码相同|
### 奇怪的 char
`char`在内存中的存储空间只有一个字节，因此要注意各种类型转换时候的“整型提升”和“截断”问题
### 练习 1：判断输出
```c
int main()
{
	char a = -1;
	signed char b = -1;
	unsigned char c = -1;
	printf("%d\n%d\n%d\n", a,b,c);
}
```
**过程和思路：**
注意截断和整型提升。
```c
int main()
{
	char a = -1;
    //原码 10000000 00000000 00000000 00000001
    //反码 11111111 11111111 11111111 11111110
    //补码 11111111 11111111 11111111 11111111
    //11111111
	signed char b = -1;
    //11111111
	unsigned char c = -1;
    //11111111
	printf("%d\n%d\n%d\n", a,b,c);
    //从 char 打印整型的时候，要发生整型提升：整型提升：正数补0，负数补1
    //a：11111111 11111111 11111111 11111111 -> -1
    //b：11111111 11111111 11111111 11111111 -> -1
    //c：00000000 00000000 00000000 11111111 -> 255
}
```
### 练习 2：判断输出
```c
    char a = -128;
    printf("%u\n",a);
```
**过程和思路：**
%u 占位符表示输出无符号整数。
```c
    char a = -128;
    //10000000 00000000 00000000 10000000
    //先变补码，再截断
    //11111111 11111111 11111111 01111111
    //11111111 11111111 11111111 10000000
    //10000000
    printf("%u\n",a);
    //打印十进制的无符号数字
    //整型提升，补 1
    //11111111 11111111 11111111 10000000
    //由于打印 %u，因此不用再把补码变原码了（无符号补码=原码）换算成十进制后直接打印
    //4294967168
```
### 练习 3：判断输出
```c
    char a = 128;
    printf("%u\n",a);
```
**注意事项**：和上题类似。
```c
    char a = 128;
    //溢出了，它就等于 -127
    //10000000 00000000 00000000 10000000
    //先变补码，再截断
    //11111111 11111111 11111111 01111111
    //11111111 11111111 11111111 10000000
    //10000000
    printf("%u\n",a);
    //打印十进制的无符号数字
    //整型提升，补 1
    //11111111 11111111 11111111 10000000
    //由于打印 %u，因此不用再把补码变原码了（无符号补码=原码）换算成十进制后直接打印
    //4294967168
```
### 练习 4：
```c
    int i = -20;
    unsigned int j = 10;
    printf("%d\n", i + j);
```
**注意事项**：加法都是以补码形式运算
```c
    int i = -20;
    //10000000 00000000 00000000 00001100 原码
    //11111111 11111111 11111111 11110011 反码
    //11111111 11111111 11111111 11110100 补码
    unsigned int j = 10;
    //00000000 00000000 00000000 00000110 原码 = 反码 = 补码
    printf("%d\n", i + j);
    //11111111 11111111 11111111 11111010 补码
    //11111111 11111111 11111111 11111001 反码
    //10000000 00000000 00000000 00000110 原码 = -10

```
### 练习 5
```c
    unsigned int i;
    for(i = 9;i>=0;i--)
    {
        printf("%u\n",i);
    }
```
**注意事项**：i 是无符号数字，所以会无限循环。
### 练习 6
```c
    char a[1000];
    int i;
    for(i = 0; i < 1000; i++)
        a[i] = -1 - i;
    printf("%d",strlen(a));//255
```
**注意事项**：当 i 走到 -128 之后，会回到 127 继续减，直到减到 0
0 在 ASCII 码中表示 `\0`，即字符串终止符号，这时候，会终止函数`strlen()`的读取，因此结果是 255
### 练习 7
```c
unsigned char i = 0;
int main()
{
    for (i = 0; i <= 255; i++)
        printf("helloworld\n");
    return 0;
}
```
**注意事项**：这道题和练习 5 有异曲同工之妙，由于`char`的取值范围问题，所以造成了死循环
## 大小端、字节数
大端存储模式：数据的高位保存在内存的高地址中，数据的高位保存在内存的低地址中
小端存储模式：vice versa
大多数都是小端存储。小的数字放在左边，看起来就像是放反了一样。
### 练习 3：写一个程序判断内存“字节序”
存储模式是大端存储还是小端存储
思路：查看一个特定数字 的首位，例如，对于数字 1
如果是大端存储，那就是 00 00 00 01
如果是小端存储，那就是 01 00 00 00
用`char`类型的指针把第一位拿出来。
```c
int check_sys()
{
    //如果当前内存存储模式是小端，返回 1；否则返回 0
    int a = 1;
    char* p = (char*)&a;
    return *p;
}
//更精简的写法
int check_sys1()
{
    int a = 1;
    return *(char*)&a;
}
```
## 浮点在内存中的存储
### 浮点的创建







