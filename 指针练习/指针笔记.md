今天进指针了，希望能这节课把指针基础弄好。这个功能对于 c 来说太重要了。

笔记方面，前几天感觉我的笔记暴露了一个不好的信号，就是笔记记得太认真详细了，拖慢了我学习的进度。markdown 确实是一个很好的工具，但是我不能因为
沉迷于它的花花绿绿而忘记了学习的紧迫性，不能像那些“学渣”一样仅仅注重表面功夫，而疏忽了知识的真正吸收。整理知识的作用是吸收知识，而不是为了展示给谁看。之前多写代码培养熟悉度，到现在，这些重复性的操作可以适当减少。
## 指针基础
是一个变量，存储了另一个变量的地址，可以通过访问指针的方式，找到指针指向的数据的内存。存放在指针中的值，都会被当成地址处理。

### 寻址空间
取决于机器是 32 位的还是 64 位的。32 位的机器有 32 根地址线，地址的长度是 32 个比特位也就是 4 个字节，可以产生 4 GB 的 0 和 1 的组合，也就是 4 GB 的寻址空间，因此在运行较大的程序的时候，32 位系统可能就会爆掉。64 位的机器地址长度是 8 个字节，就避免了这个问题。

### 指针类型
虽然指针大小都是 4/8 个字节，但是还是存在不同类型的指针，例如`int* p`和`double* p2`</br>
指针类型决定了：</br>
1、指针进行解引用操作的时候，能访问空间的大小。`int* p`四个字节，`char* p`一个字节。</br>
2、指针的步长。</br>

### 野指针的产生
指针指向未知的位置。</br>
造成野指针的原因：</br>
1、局部变量不初始化，默认为随机值。指针不初始化，就是野指针，非常危险。</br>
```c
    int *p;
```

2、指针越界访问。
```c
    int arr[10] = {0}；
    int* p = arr;
    for(int i = 0;i < 12;i++)
        *p++ = 1;
```
3、指针指向的内存释放
```c
int* test()
{
    int a = 10;
    return &a;
}
int main()
{
    int *p = test(); //这一步，确实接收到了 a “生前”的地址，但是已经没有意义了
    *p = 20; //但是这一步无法完成，因为 a 已经死了（局部变量离开之后会进行内存释放）
}
```
### 野指针的规避
1、初始化的时候要赋值。实在不知道怎么赋值，那就指向`NULL`
```c
	int* p = NULL; //NULL对于指针很有用
```
2、指针不用了之后要置零。
```c
	int* p = &a;
	...
	p = NULL;
```
3、使用指针之前注意判空/判断是否合法
```c
	if ( p != NULL){}
```
### 指针的运算
**指针 +- 整数**</br>
指针移动
```c
	int arr[10] = { 0 };
	int* p = &arr;
	int* p1 = &arr[5];
	for (int i = 0; i < sizeof(arr) / sizeof(int); i++)//利用指针 给数组赋值
		*(p++) = i;
	for (int i = 0; i < sizeof(arr) / sizeof(int); i++)
		printf("%d ", arr[i]);
	printf("\n%d\n", *p1);// 5
	p1 = p1 + 3;
	printf("%d\n", *p1);// 8
```
**指针 +- 指针**</br>
计算两个地址之间的距离
```c
	int arr[9] = {1,2,3,4,5,6,7,8,9};
	printf("%d\n", &arr[9] - &arr[4]); // 5
```

### 指针和数组
数组名究竟是什么？大部分情况下，代表首元素的地址。</br>例外：`sizeof(arr)` 计算的是整个数组的大小。</br> `&arr`取出的是整个数组的地址。+ 1 之后会直接
跳到数组末尾。</br>

### 二级指针：指针的指针








